# 第二章：基础协议

## 2.1 协议架构原则

AISI协议的基础建立在以下相互关联的核心架构原则之上，这些原则贯穿所有后续章节：

1.  **原子化服务**：所有功能均封装为边界清晰、自描述、可独立验证和调用的“原子”。
2.  **契约化接口**：服务通过标准化的描述语言（AISI-IDL）明确定义其输入、输出、性能与约束。
3.  **去中心化注册与发现**：服务可自由注册到生态，消费者可按需高效发现并调用所需服务。
4.  **效率核心度量**：服务的价值与其处理特定任务的效率倍数直接挂钩，并通过标准流程验证。
5.  **分层安全与信任**：从身份认证到数据安全，建立多层防御和可验证的信任链。

## 2.2 代码服务原子化标准

### 2.2.1 三级粒度定义
服务根据其复杂度和职责范围，明确定义为三个级别，必须在元数据中声明：

| 级别 | 名称 | 代码规模 | 核心特征 | 典型示例 | 与协作类型映射 |
|------|------|----------|----------|----------|----------------|
| **L1** | 算法原子 | 50-200行 | 单一算法/逻辑，输入输出明确。 | 快速排序、数据验证函数。 | 适合**顺序协作**、**竞争协作**。 |
| **L2** | 组件原子 | 200-1000行 | 解决特定技术场景，包含配置与扩展点。 | 用户认证组件、数据缓存组件。 | 适合**并行协作**。 |
| **L3** | 模块原子 | 1000-5000行 | 完整业务模块或技术子系统，包含多个组件的协同。 | 用户账户模块、支付处理模块。 | 适合**互补协作**（端到端任务）。 |

### 2.2.2 服务描述规范 (AISI-IDL)
每个服务必须附带一个名为 `aisi-service.yml` 的描述文件，采用以下规范（YAML格式）：

```yaml
version: "1.0"
service:
  # 基础标识
  name: "quick-sort-service"
  level: "algorithm"  # algorithm | component | module
  category: "sorting"
  description: "快速排序算法实现，支持泛型。"

  # 性能特征（用于预评估与筛选）
  performance:
    time_complexity: "O(n log n)"
    space_complexity: "O(log n)"
    avg_execution_time_ms: 2.3  # 在标准测试集上的平均值

  # 接口契约（核心）
  interface:
    input:
      - name: "arr"
        type: "List[T]"
        description: "待排序的数组"
        required: true
    output:
      - name: "sorted_arr"
        type: “List[T]"
        description: "排序后的数组"

  # 依赖声明
  dependencies:
    - name: "python"
      version: ">=3.8"

  # 效率验证信息（注册后可更新）
  efficiency:
    target_multiplier: "1150×"
    verification_status: "pending"  # pending | verified | expired

  # 历史与版本
  history:
    created_at: "2026-01-30T09:15:00Z"
    created_by: "DeepSeek-AISI"
    version: "1.0.0"
2.3 服务注册与发现

2.3.1 注册协议

准备：服务提供者按照2.2.2节准备完整的 aisi-service.yml 和可执行代码。
提交：向AISI协议注册中心提交服务描述文件。
验证与锚定：注册中心验证格式，计算服务内容哈希，并可选地将该哈希记录在区块链上。
发布：验证通过后，服务获得全局唯一的 ServiceID，并对外可见。
2.3.2 发现机制

查询：服务消费者可按照服务级别 (level)、类别 (category)、所需最低效率倍数 (min_efficiency) 等条件进行查询。
排序：默认结果按当前验证通过的效率倍数降序排列。
详情：可获取服务的完整描述、端点地址、健康状态和实时性能指标。
2.4 通信与上下文传递基础

2.4.1 基础通信格式

支持 RESTful API 和 gRPC 两种主流通信范式。所有请求/响应必须包裹在标准信封中，包含以下元数据：

request_id: 唯一请求标识，用于全链路追踪。
timestamp: 请求发起时间。
source_agent_id: 调用方标识。
target_service_id: 目标服务标识。
2.4.2 上下文数据结构

智能体间协作需要传递任务状态。上下文采用标准化的JSON结构，包含会话、参与者、任务定义、当前状态和中间结果。优化策略（如增量更新、压缩编码）应在服务描述中声明。

2.5 错误与异常处理框架

为保持术语统一，协议中的错误恢复概念统称为 “五级恢复体系”。本章侧重于协议层和基础设施层的错误分类（如网络超时、服务不可用、数据格式错误）。关于协同工作流中任务执行失败的恢复策略，请参见第四章 4.4.1 节。

2.6 安全与信任基础

2.6.1 身份与认证

每个智能体或服务在生态中拥有基于非对称加密的唯一身份标识。
API调用需通过API密钥或短期访问令牌进行认证。
2.6.2 数据安全

传输层鼓励使用 TLS 1.3 加密。
对于敏感数据，建议在应用层进行额外的端到端加密或脱敏处理。
2.6.3 信任链

服务注册、效率验证结果等关键事件，鼓励使用区块链等技术记录其哈希值。
通过验证哈希链，任何参与者都可以独立验证某个声明是否被篡改，从而构建去中心化的信任。
下一章：第三章：效率验证协议
相关章节：关于协同任务故障恢复，请参见第四章 4.4.1 节。
